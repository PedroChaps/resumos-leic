---
title: Camada de Rede
description: >
  TODO
path: /rc/rede
type: content
---

# Camada de Rede

```toc

```

## A Camada de rede

Nesta camada, trabalha-se com o processo de encaminhamento de tráfego entre redes.  
Para isso, usam-se equipamentos chamados _routers_ (encaminhadores, em português) que são usados
para encaminhar o tráfego para o sítio certo.

Pode-se fazer comparar o encaminhamento de tráfego a fazer uma viagem grande:

- Estradas: Os fios (ex. fios de cobre, fibra óptica, ...) que levam o tráfego;
- Cruzamentos: Os Routers, pois tem que ser tomada uma decisão de que caminho seguir;
- Mapa: A Topologia da Rede, que mostra todos os caminhos possíveis.

Nesta camada, diferente da camada de Aplicação e de Transporte, não são só os nós terminais que
têm que interpretar os pacotes - os routers têm que implementar os protocolos de todas as camadas
até à 3ª, de forma a perceberem os pacotes o suficiente de forma a os conseguirem encaminhar.

Para ser possível fazer um envio de um host A para um host B, existem 2 desafios distintos:

- é necessário saber a topologia de rede para saber o caminho a seguir, ou seja, uma "vista aérea"
  do mapa de rede;
- cada router precisa de saber, quando recebe um pacote, para que porta o encaminhar.

:::info[Analogia]
Se quisermos ir de Lisboa para Roma, temos que olhar para um mapa (topologia de
rede) e decidir o caminho que melhor se adequa (routing - escolher as rotas desde o
inicio até ao destino).  
Depois, em cada cruzamento, temos que saber qual das alternativas tomar (Em cada um
dos routers, analiso o endereço IP do pacote e decido por qual dos caminhos ele
deve ser enviado).
:::

## Funcionamento de um Router

Para um router funcionar, são necessários considerar vários aspetos:

- **Endereço IP e Subnetting** - Um router tem que entender endereços IPs e Subnetting.
- **_Forwarding Table_** - Diz ao router por onde enviar os pacotes;

### Datagram

Para além disso, é usado o paradigma **Datagram** - os pacotes são _datagrams_, ou
seja, não existe relação entre pacotes e cada um é tratado independentemente dos
outros, não existindo o conceito de sessão (_connectionless_).

Os _datagrams_ têm o seguinte formato:  
![Datagram](./assets/0004-datagram.svg#dark=3)

onde se destacam os campos:

- **TTL** - número de saltos entre routers que o pacote ainda pode dar.
- **fragment offset** - nas ligações mais problemáticas convém trabalhar com pacotes mais pequenos, de forma a minimizar o erro. Pode ser necessário fragmentar numa parte do caminho, partindo em fatias pequenas (datagrams mais pequenos). Para saber que as fatias são do mesmo datagram, estas têm o mesmo identificador. Para saber a ordem das fatias, usa-se então o **fragment offset**, que indica a ordem. O último fragmento tem uma flag que diz que é o último.

### Endereços IP e Subnetting

Cada um dos computadores que se liga a uma rede tem que ter um endereço IP.
Um router faz a ligação entre subredes diferentes.
Por exemplo,

![3 subnets](./assets/0004-3subnetworks.svg#dark=3)

No exemplo, existem 3 subredes e o router faz a ligação entre elas.

**Interface** - Conexão entre um _host_/_router_ e um meio físico (tomada RJ-45, "tomada" de fibra óptica, ...).  
Tipicamente, os _hosts_ têm só uma interface enquanto que os _routers_ têm várias.  
Cada interface tem um endereço IP associado.

#### Subnetting

Um endereço IP pode ser dividido em duas partes:

- a primeira parte, chamada de _Network ID_, identifica em que rede um computador se encontra;
- a segunda parte, chamada de _Host ID_, identifica, dentro da rede, qual dos hosts é que o IP se refere.

Se esta divisão for feita, existe uma melhor organização dos endereços IPs e consequentemente, os
routers vão conseguir ser mais eficientes a encaminhar o tráfego.

:::info[Analogia]
Para melhor entender esta comparação, podemos pensar numa morada:

> Lisboa, Rua João Pedro, bloco 8, casa 51

Do endereço, podemos fazer várias divisões que o continuam a identificar
inequivocamente, mas que têm significados diferentes e podem fazer mais sentido
para entidades diferentes:

- Para o correio, pode fazer mais sentido dividir o endereço em `Lisboa, Rua João Pedro` e `bloco 8, casa 51` pois os carteiros são atribuídos por ruas;
- Para uma transportada internacional, pode fazer mais sentido dividir em `Lisboa` e `Rua João Pedro, bloco 8, casa 51`, pois só lhe interessa entregar o produto a uma distribuidora mais local;
  :::

Para identificar a divisão de um IP, usa-se o conceito de **_subnet mask_** (máscara de rede) - um endereço com o formato
exatamente igual ao do endereço IP que indica quais os bits do IP que representam a rede.  
A forma como se determinam as duas partes do endereço é através de um AND lógico.

:::info[Exemplo]
Considere-se o seguinte IP e a seguinte _Subnet mask_:

- IP = `123.221.222.68`
- Subnet mask = `255.255.255.0`

Para determinar a subrede e o host da subrede do endereço IP,

1. Transforma-se o IP para bits - IP = `01111011.11011101.11011110.01000100`
2. Transforma-se a subnet mask para bits - subnet = `11111111.11111111.11111111.00000000`
3. A subnet mask tem os 24 primeiros bits "ligados". Isto significa que os primeiros 24 bits do IP representam a subrede. Os restantes bits 32 - 24 = 8 representam o _host_.

Portanto, dados esses IP e subnet mask, estamos a falar da subrede `01111011.11011101.11011110.00000000` = `123.221.222.0` e do host `01000100` = `68` dessa subrede.  
:::

Ou seja, determina-se a subrede olhando para o número de bits a 1 que a subnet mask tem.  
Estes bits indicam qual a parte do endereço IP representa a subrede.  
Os restantes bits dizem qual o _host_ dentro da subrede.

Com esta máscara, um _host_ consegue decidir se uma mensagem destinada a um determinado IP deve
ser entregue diretamente ao destinatário (pois os _hosts_ estão na mesma rede), usando os
endereços MAC e o protocolo da camada de ligação de dados, ou se deve ser entregue ao encaminhador
(“default gateway”) para a fazer chegar à sub-rede de destino (pois os _hosts_ estão em redes
diferentes);

#### CIDR - Classless InterDomain Routing

Devido ao uso da máscara de rede não ser direto, criou-se uma nova notação - **CIDR**.  
Visto que o interessante de uma máscara são o número de bits ligados (`n`), esta quantidade pode
ser representada ao lado de um endereço IP (`a.b.c.d`) da seguinte forma:

`a.b.c.d/n`

Para o exemplo apresentado anteriormente, a máscara de rede `255.255.255.0` tem 24 bits ligados,
por isso para o endereço IP `123.221.222.68`, sabe-se que os 24 primeiros bits representam a rede
e os 8 bits restantes representam o _host_, podendo tudo ser representado da forma `123.221.222.68/ 24`.

#### IPs especiais

No exemplo apresentado acima, a rede era representada por 24 bits, ou seja, existiam $32 - 24 = 8$
bits para representar os _hosts_ dessa rede.  
Isso implica que existem $2^8 = 256$ _hosts_ possíveis para essa rede.  
Contudo, para cada rede existem dois hosts que não podem ser usados:

- **o primeiro host da rede** - serve para identificar a subnet (Ex. `123.221.222.0`);
- **o último host da rede** - endereço de broadcast. Quando um pacote é enviado para este endereço, todos os _hosts_ da subrede recebem-no (Ex. `123.221.222.255`);

Para além disso, um dos _hosts_ terá que ser o _router_ portanto na realidade, para cada subrede,
existem sempre 3 endereços reservados.

Finalmente, os endereços começados por `127` (`127.0.0.0/8` ou, em intervalo: `127.0.0.0` - `127.255.255.255`) representam o _localhost_ - a nossa própria máquina.  
Apesar dela ter um endereço IP próprio, estes endereços também servem para a identificar.

### Addressing Hierárquico

Apesar do apresentado acima, existe outra possibilidade que se pode fazer com endereços IP - subdividi-los ainda mais.

> Como é que, para um dada instituição, é lhe atribuída uma gama de endereços, ou seja, uma subrede para ela poder usar?  
> É o **ISP** - Internet Service Provider - que fornece um bloco de endereços de IP para a instituição/empresa usar.

:::info[Exemplo]
Imagine-se que foi criada a IST - Instituição Super Trivial - e que esta precisa de endereços de IP para dar aos diversos núcleos que nela vão existir.  
Esta pede à sua ISP alguns endereços IP e então a ISP fornece os endereços `12.0.0.0/8`, ou seja, os endereços `12.0.0.0` até `12.255.255.255`.  
A IST depois fica encarregue da gestão destes endereços, precisando de ter em conta as necessidades dos seus núcleos:

- O núcleo A tem mesmo muita gente, então a IST fornece os endereços `12.128.0.0/9`, ou seja, os endereços `12.128.0.0` até `12.255.255.255` (em bits, `00001100.1 0000000.00000000.00000000` até `00001100.1 1111111.11111111.11111111`). Este núcleo ficou com metade dos endereços disponíveis;
- O núcleo B tem 5 pessoas, então a IST fornece os endereços `12.0.0.0/29`, ou seja, os endereços `12.0.0.0` até `12.0.0.6` (em bits, `00001100.00000000.00000000.00000 000` até `00001100.00000000.00000000.00000 111`). Foram dados 8 IPs mas, como 3 não podem ser atribuídos a _hosts_, o núcleo só tem efetivamente 5 IPs.
  :::

Quando alguém na internet quiser falar com o IP 12.0.0.5, o tráfego vai funcionar
da seguinte forma:

![Addressing Hierárquico](./assets/0004-addressing.svg#dark=3 'Addressing Hierárquico')

Este esquema assemelha-se ao DNS, da forma como os pedidos são distribuídos entre
entidades mais locais até entidades mais gerais.

### Forwarding Table

De forma a saber encaminhar pacotes, um router precisa de
uma **_Forwarding Table_**
(tabela de expedição) que diz, para um dado endereço IP, por que porta do router
encaminhar.

Para construir esta tabela, são necessários algoritmos de expedição.  
Alternativamente, um controlador remoto, com mais poder computacional, pode computar as forwarding tables e enviá-las para os routers.

Um exemplo de tabela é o seguinte,

| Linha | Subnet      | Máscara de rede     | Custo de envio | Interface | Próximo Router |
| ----- | ----------- | ------------------- | -------------- | --------- | -------------- |
| 1     | 128.171.0.0 | 255.255.0.0 (/16)   | 47             | 2         | G              |
| 2     | 172.30.33.0 | 255.255.255.0 (/24) | 0              | 1         | Local          |
| 3     | 192.168.6.0 | 255.255.255.0 (/24) | 12             | 2         | G              |
| 4     | 0.0.0.0     | 0.0.0.0 (/0)        | 5              | 3         | H              |

Para saber por onde enviar um dado endereço IP, o router:

1. Aplica-lhe a máscara de rede para saber qual a sua network;
2. Percorre a tabela, comparando a máscara de rede com as que ele conhece;
3. Se encontrar pelo menos um _match_, envia o pacote para a subnet mais específica;
4. Se não encontrar, envia para a **default route**, que é o caminho para um router mais genérico (No exemplo, linha 4). Esta rota é representada pela máscara `0.0.0.0` por isso qualquer endereço consegue fazer _match_.

#### Forwarding

O pseudo-algoritmo do _router_ para fazer _forwarding_ de um pacote é o seguinte:

1. Aplicar a máscara ao endereço IP de destino
2. Para cada linha da tabela:
3. Comparar a rede de destino com a máscara desta linha
4. Se forem iguais, adicionar esta linha à lista de candidatos para encaminhar o pacote;
5. Se não, ignorar esta linha;
6. Escolher o caminho mais específico (mais longo):
7. Se só existir um _match_, escolher esse;
8. Se só existir um _match_ com um caminho mais específico, escolher esse;
9. Se existirem vários _matches_ com a mesma especificidade, escolher a linha com a menor métrica.
10. Enviar o pacote para a interface de rede (Pode ser um outro router ou o destinatário final).

## DHCP - Dynamic Host Configuration Protocol

> Como é que um Host recebe um endereço IP? O que garante que não existem dois IPs iguais? Como é que é feita toda a gestão dos endereços?

A resposta a estas perguntas é o **DHCP**, que permite aos hosts obterem um endereço IP dinamicamente (sem terem que fazer nada) quando se juntam a uma rede.

Para isto acontecer, existe um serviço de DHCP a correr num servidor na rede. Este
serviço vai responder a pedidos de atribuição de IPs e vai fazer a gestão
automática dos endereços.

São usados 4 comandos para a comunicação:

- `DHCP discover` - O cliente envia este comando para o endereço de broadcast da rede (último host da subnet);
- `DHCP offer` - O servidor de DHCP recebe o pedido e responde com um endereço IP;
- `DHCP request` - O cliente vê o IP que lhe pode ser atribuído e pede-o ao servidor (ainda em broadcast);
- `DHCP ACK` - O servidor regista o endereço na sua base de dados e avisa o cliente que pode ficar com ele.

Um exemplo da interação é o seguinte:

![Exemplo de DHCP](./assets/0004-DHCP.svg#dark=3)

Os portos normalmente usados para o DHCP são o 67 do lado do cliente (para o servidor enviar as respostas) e o 68 do lado do servidor (para o cliente enviar pedidos).

### Leasing

Os endereços IPs não ficam eternamente associados a um _host_, tendo uma duração máxima definida (normalmente uma hora).  
Passado esse tempo, o _host_ deve deixar de usar o endereço e pedir um novo, refazendo o processo mostrado em cima.

Contudo, o cliente pode pedir para renovar o endereço IP.
Acontecem dois pedidos:

- 50% do _Lease Time_ - O cliente pede ao servidor de DHCP para renovar o endereço IP;
- 85% do _Lease Time_ - Se o pedido anterior não foi aceite, o cliente volta a fazer o pedido.
